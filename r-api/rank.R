

#' @title Rank acceptable and nearly acceptable models prior to shortlisting
#' @description Order model info by rounded performance score, then by distance to the query, then by the performance preferences as chosen by the user.
#'
#' @param distances List with dataframes containing all distances from compute_distacnes()
#' @param preferences List generated by query_settings()
#'
#' @return Ordered dataframes with models to be ranked
#' @export
#'
#' @examples rank_models(distances=list_of_dataframes_with_distances,
#' preferences=lis("acc_width"=...,"pre_width"=...),"rec_width"=...,"tra_width"=...)
rank_models<-function(groupcodes,preferences){
  ## Use all distances, data and criteria to rank models

  verbose<-T

  userpref<-sort(unlist(preferences))

  sort_priorities<-c()

  for (i in 1:length(userpref)) {
    switch (substr(names(sort(unlist(userpref)))[i],1,3),
            "pre" = sort_priorities<-c(sort_priorities,"precision"),
            "rec" = sort_priorities<-c(sort_priorities,"recall"),
            "acc"= sort_priorities<-c(sort_priorities,"accuracy"),
            "tra" = sort_priorities<-c(sort_priorities,"training_time_std"),
    )
  }

  # cols_2_include<-c(1,2,15,17,19,21,30,31)
  # [1] "model.name"                "algo.fam"                  "dataset"
  # [4] "number.rows"               "columns.change"            "first.data.type"
  # [7] "second.data.type"          "has.text.data"             "numeric.ratio"
  # [10] "categorical.ratio"         "datetime.ratio"            "text.ratio"
  # [13] "categorical.text.encoding" "classification.type"       "accuracy"
  # [16] "accuracy.label"            "precision"                 "precision.label"
  # [19] "recall"                    "recall.label"              "training.time"
  # [22] "training.time.label"       "sampling"                  "language"
  # [25] "test.size"                 "number.custom.params"      "output"
  # [28] "performance.label"         "performance.score"         "traintime.std"
  # [31] "performance.score.cont"
  cols_2_include<-c("model_name","fam_name","accuracy","precision","recall","training_time_std","performance_score")

  if(verbose){print("Connecting to mongo to get enriched models")}
  enriched_models<-mongolite::mongo(collection = "enriched_models",
                                    db="assistml",
                                    url="mongodb://admin:admin@localhost:27017/")
  # Test string of model codes
  # print( paste(groupcodes$acceptable_models,collapse = "\", \"") )


  # rank of acc models ####
  accmodels_data<-enriched_models$find(query =eval(parse(text = paste0("'{\"model_name\":{\"$in\":[\"",paste(groupcodes$acceptable_models,collapse = "\", \""),"\"]}}'"))))
  accmodels_data<-accmodels_data[,names(accmodels_data) %in% cols_2_include]


  print("")
  print("Obtained accmodels_data")
  print(names(accmodels_data))

  # accmodels_data<-model_data[as.character(model_data$model.name) %in% ,cols_2_include]

  accmodels_data$accuracy<-round( as.numeric(accmodels_data$accuracy) ,4)
  accmodels_data$precision<-round( as.numeric(accmodels_data$precision) ,4)
  accmodels_data$recall<-round( as.numeric(accmodels_data$recall) ,4)
  accmodels_data$training_time_std<-round( as.numeric(accmodels_data$training_time_std) ,4)
  accmodels_data$performance_score<-as.numeric(accmodels_data$performance_score)

  # # Adds distance to query to data frame
  # accmodels_dist<-distances$query_accmodels
  # accmodels_dist<-cbind(accmodels_dist,"model_name"=rownames(accmodels_dist))
  # accmodels_data<-merge(accmodels_data,accmodels_dist,by = "model_name")
  # accmodels_data$query<-(1-(accmodels_data$query/distances$scales$query)) # Expresses percentage of similarity to the query
  #
  # accmodels_indist<-distances$accmodels
  # accmodels_indist<-cbind(accmodels_indist,"model_name"=rownames(accmodels_indist))
  # accmodels_data<-merge(accmodels_data, accmodels_indist,by="model_name")

  accmodels_data<-accmodels_data[with(accmodels_data,order(-performance_score,
                                             # -query, # From most similar to least similar
                                             eval(parse(text = paste0("-",sort_priorities[1]))),
                                             eval(parse(text = paste0("-",sort_priorities[2]))),
                                             eval(parse(text = paste0("-",sort_priorities[3]))),
                                             eval(parse(text = paste0("-",sort_priorities[4])))
                                             )),]

  write.csv(accmodels_data,"accms_ranked.csv") # Careful with query distances

  print(paste("Finished creating acceptable models rank. Score range:",
              max(accmodels_data$performance_score),
              "-",
              min(accmodels_data$performance_score)))

  # Rank of nearly acceptable models ####


  if(verbose){
    print( paste(groupcodes$nearly_acceptable_models,collapse = "\", \"") )
  }

  if(groupcodes$nearly_acceptable_models[1] %in% c("none")){
    #  There are no NACC models to rank

    return(list("accmodels_rank"=accmodels_data,
                "naccmodels_rank"="none"))
  }else{

    # There are nacc models to rank
    naccmodels_data<-enriched_models$find(query =eval(parse(text = paste0("'{\"model_name\":{\"$in\":[\"",paste(groupcodes$nearly_acceptable_models,collapse = "\", \""),"\"]}}'"))))
    naccmodels_data<-naccmodels_data[,names(naccmodels_data) %in% cols_2_include]

    print("")
    print("Obtained naccmodels_data")
    print(names(naccmodels_data))
    # naccmodels_data<-model_data[as.character(model_data$model.name) %in% rownames(distances$query_naccmodels),cols_2_include]

    naccmodels_data$accuracy<-round( as.numeric(naccmodels_data$accuracy) ,4)
    naccmodels_data$precision<-round(as.numeric(naccmodels_data$precision) ,4)
    naccmodels_data$recall<-round(as.numeric(naccmodels_data$recall) ,4)
    naccmodels_data$training_time_std<-round( as.numeric(naccmodels_data$training_time_std) ,4)
    naccmodels_data$performance_score<-as.numeric(naccmodels_data$performance_score)

    # # Adds distance to query to data frame
    # naccmodels_dist<-distances$query_naccmodels
    # naccmodels_dist<-cbind(naccmodels_dist,"model_name"=rownames(naccmodels_dist))
    # naccmodels_data<-merge(naccmodels_data,naccmodels_dist,by="model_name")
    # naccmodels_data$query<-1-(naccmodels_data$query/distances$scales$query) # Expresses percentage of similarity to the query
    #
    # naccmodels_indist<-distances$naccmodels
    # naccmodels_indist$model_name=rownames(naccmodels_indist)
    # naccmodels_data<-merge(naccmodels_data,naccmodels_indist,by="model_name")

    naccmodels_data<-naccmodels_data[with(naccmodels_data,order(-performance_score,
                                                                # -query, # From most similar to least similar
                                                                eval(parse(text = paste0("-",sort_priorities[1]))),
                                                                eval(parse(text = paste0("-",sort_priorities[2]))),
                                                                eval(parse(text = paste0("-",sort_priorities[3]))),
                                                                eval(parse(text = paste0("-",sort_priorities[4])))
    )),]

    write.csv(naccmodels_data,"naccms_ranked.csv") # Careful with query distances

    print(paste("Finished creating nearly acceptable models rank. Score range:",
                max(naccmodels_data$performance_score),
                "-",
                min(naccmodels_data$performance_score)))

    return(list("accmodels_rank"=accmodels_data,
                "naccmodels_rank"=naccmodels_data))
  }



  }




#' @title Make a stratified selection of models as final result
#' @description Makes a stratified selection of ranked models for both the acceptable and nearly acceptable models.
#'
#' @param ranked_models Ordered dataframe generated by rank_models
#'
#' @return List with two dataframes, one for each model group.
#' @export
#'
#' @examples shortlist_models(list("accmodels_rank"=dataframe,"naccmodels_rank"=dataframe))
shortlist_models<-function(ranked_models){
  ## Stratify accmodels and naccmodels by algofam

  ## Section :Set retain ratio####
  retain<-0.1

  ## Section :Shortlisting the accmodels ####
  accmodels<-ranked_models$accmodels_rank
  accmodels$fam_name<-factor(accmodels$fam_name)

  accms_sample<-ceiling(tapply(accmodels[,2],accmodels[,2],length)*retain)

  accmodels_choice<-accmodels[1,] #Sample row to create the DF
  for (i in 1:length(accms_sample)) {
    accmodels_tmp<-accmodels[as.character(accmodels$fam_name) %in% names(accms_sample)[i],]
    accmodels_choice<-rbind(accmodels_choice,accmodels_tmp[1:accms_sample[i],])
  }

  accmodels_choice<-accmodels_choice[2:nrow(accmodels_choice),] # Removes sample row

  accmodels_choice<-accmodels_choice[with(accmodels_choice,order(-performance_score) ),] #Reorders the models





## Section :Shortlisting the naccmodels####

  if(ranked_models$naccmodels_rank %in% "none"){
    # Case there are no NACC models to rank
    print(paste("Finished choosing. Acceptable models:",nrow(accmodels_choice)))

    return(list("accms_choice"=accmodels_choice,
                "naccms_choice"="none"))

  }else{
    # Case there are NACC models to shortlist

    naccmodels<-ranked_models$naccmodels_rank
    naccmodels$fam_name<-factor(naccmodels$fam_name)

    naccms_sample<-ceiling(tapply(naccmodels[,2],naccmodels[,2],length)*retain)

    naccmodels_choice<-naccmodels[1,] #Sample row to build DF
    for (i in 1:length(naccms_sample)) {
      naccmodels_tmp<-naccmodels[as.character(naccmodels$fam_name) %in% names(naccms_sample)[i],]
      naccmodels_choice<-rbind(naccmodels_choice,naccmodels_tmp[1:naccms_sample[i],])
    }

    naccmodels_choice<-naccmodels_choice[2:nrow(naccmodels_choice),] #Removes sample row

    naccmodels_choice<-naccmodels_choice[with(naccmodels_choice,order(-performance_score) ),] #Reorders the models

    print(paste("Finished choosing. Acceptable models:",nrow(accmodels_choice),"Nearly acceptable models:",nrow(naccmodels_choice)))

    return(list("accms_choice"=accmodels_choice,
                "naccms_choice"=naccmodels_choice))
  }


}
